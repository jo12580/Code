C51 COMPILER V9.01   DRIVE                                                                 11/07/2021 19:37:40 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DRIVE
OBJECT MODULE PLACED IN drive.OBJ
COMPILER INVOKED BY: D:\Software\Keil\32\C51\BIN\C51.EXE drive.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\drive.lst) TABS(2)

line level    source

   1          #include<drive.h>
   2          #include<reg52.h>
   3          
   4          sbit ENA = P2^0;   //右点机使能
   5          sbit IN1 = P2^1;   //为0右轮反转
   6          sbit IN2 = P2^2;   //为0右轮正转
   7          sbit IN3 = P2^3;   //为0左轮正转
   8          sbit IN4 = P2^4;   //为0左轮反转
   9          sbit ENB = P2^5;   //左电机使能
  10          
  11          sbit redleft = P2^7;  //灰度传感器
  12          sbit redright= P2^6;
  13          sbit left1 = P1^3;  //黑白探头
  14          sbit left2 = P1^2;
  15          sbit right1 = P1^1;
  16          sbit right2 = P1^0;
  17          
  18          u8 PWMCnt1 = 0;
  19          u8 PWMCnt2 = 0;
  20          u8 cntPWM1 = 0;
  21          u8 cntPWM2 = 0;
  22          
  23          unsigned int j;
  24          
  25          //i = 1时， 大概延时10us
  26          void delay(u16 i)
  27          {
  28   1          while (i--);
  29   1      }
  30          
  31          void Timer0Init()
  32          {
  33   1        TH0 = 0xFF;
  34   1        TL0 = 0xA3;
  35   1        TMOD &= 0xF0;
  36   1        TMOD |= 0x01;
  37   1        EA = 1;
  38   1        ET0 = 1;
  39   1        TR0 = 1;
  40   1      }
  41          
  42          void run()
  43          {
  44   1        if((redleft == 1)&&(redright == 1))  
  45   1        {
  46   2          delay(50000);delay(50000);
  47   2          Backward();
  48   2        }
  49   1        if((redleft == 1)&&(redright == 0)) 
  50   1        {
  51   2          TurnLeft1();
  52   2        }
  53   1        if((redleft == 0)&&(redright == 1)) 
  54   1        {
C51 COMPILER V9.01   DRIVE                                                                 11/07/2021 19:37:40 PAGE 2   

  55   2          TurnRight1();
  56   2        }
  57   1        if((redleft == 1)&&(redright == 1)) 
  58   1            XunJi();
  59   1      }
  60          
  61          //void Timer1Init(void)   //100微秒@11.0592MHz
  62          //{
  63          //  TMOD &= 0x0F;   //设置定时器模式
  64          //  TL1 = 0xCD;   //设置定时初值
  65          //  TH1 = 0xD4;   //设置定时初值
  66          //  TF1 = 0;    //清除TF1标志
  67          //  TR1 = 1;    //定时器1开始计时
  68          //  EA = 1;
  69          //  ET0 = 1;
  70          //}
  71          
  72          void TurnRight1()      //右转
  73          {
  74   1      //  IN1 = 0;  //右轮反转
  75   1      //  IN2 = 1;
  76   1      
  77   1        IN3 = 1;  //左轮正转
  78   1        IN4 = 0;
  79   1        cntPWM1 = 15;
  80   1        cntPWM2 = 15;
  81   1      }
  82          
  83          void TurnRight2()      //右转
  84          {
  85   1      //  IN1 = 0;  //右轮反转
  86   1      //  IN2 = 1;
  87   1      
  88   1        IN3 = 1;  //左轮正转
  89   1        IN4 = 0;
  90   1        cntPWM1 = 15;
  91   1        cntPWM2 = 15;
  92   1      }
  93          
  94          void TurnLeft1()        //左转
  95          {
  96   1        IN1 = 1;
  97   1        IN2 = 0;    //右轮正转
  98   1      
  99   1      //  IN3 = 0;
 100   1      //  IN4 = 1;    //左轮反转
 101   1        cntPWM1 = 15;
 102   1        cntPWM2 = 15;
 103   1      }         
 104          
 105          void TurnLeft2()        //左转
 106          {
 107   1        IN1 = 1;
 108   1        IN2 = 0;    //右轮正转
 109   1      
 110   1      //  IN3 = 0;
 111   1      //  IN4 = 1;    //左轮反转
 112   1        cntPWM1 = 15;
 113   1        cntPWM2 = 15;
 114   1      } 
 115            
 116          void Forward()         //前进
C51 COMPILER V9.01   DRIVE                                                                 11/07/2021 19:37:40 PAGE 3   

 117          {
 118   1        IN1 = 1;
 119   1        IN2 = 0;    //右轮正转
 120   1      
 121   1        IN3 = 1;    //左轮正转
 122   1        IN4 = 0;
 123   1        
 124   1        cntPWM1 = 15;
 125   1        cntPWM2 = 15;
 126   1      }
 127          
 128          void Backward()          //后退
 129          {
 130   1        IN1 = 0;  //右轮反转
 131   1        IN2 = 1;
 132   1      
 133   1        IN3 = 0;
 134   1        IN4 = 1;  //左轮反转
 135   1        cntPWM1 = 15;
 136   1        cntPWM2 = 15;
 137   1      }
 138          
 139          void Stop()           //停止
 140          {
 141   1        IN1 = 0;
 142   1        IN2 = 0;
 143   1      
 144   1        IN3 = 0;
 145   1        IN4 = 0;
 146   1      }
 147          void XunJi()
 148          
 149          {
 150   1        unsigned char flag = 0;
 151   1      
 152   1        if((left1 == 0)&&(left2 == 0)&&(right1 == 0)&&(right2 == 0))   //0 0 0 0
 153   1          flag = 0;
 154   1      
 155   1        if((left1 == 0)&&(left2 == 0)&&(right1 == 0)&&(right2 == 1))   //0 0 0 1
 156   1          flag = 1;
 157   1      
 158   1        if((left1 == 0)&&(left2 == 0)&&(right1 == 1)&&(right2 == 0))   //0 0 1 0
 159   1          flag = 1;
 160   1      
 161   1        if((left1 == 0)&&(left2 == 0)&&(right1 == 1)&&(right2 == 1))   //0 0 1 1
 162   1          flag = 1;
 163   1      
 164   1        if((left1 == 0)&&(left2 == 1)&&(right1 == 0)&&(right2 == 0))   //0 1 0 0
 165   1          flag = 3;
 166   1      
 167   1        if((left1 == 0)&&(left2 == 1)&&(right1 == 0)&&(right2 == 1))   //0 1 0 1
 168   1          flag = 1;
 169   1      
 170   1        if((left1 == 0)&&(left2 == 1)&&(right1 == 1)&&(right2 == 0))   //0 1 1 0
 171   1          flag = 5;
 172   1        
 173   1        if((left1 == 0)&&(left2 == 1)&&(right1 == 1)&&(right2 == 1))    //0 1 1 1
 174   1          flag = 1;
 175   1        
 176   1        if((left1 == 1)&&(left2 == 0)&&(right1 == 0)&&(right2 == 0))   //1 0 0 0
 177   1          flag = 3;
 178   1        
C51 COMPILER V9.01   DRIVE                                                                 11/07/2021 19:37:40 PAGE 4   

 179   1        if((left1 == 1)&&(left2 == 0)&&(right1 == 0)&&(right2 == 1))   //1 0 0 1
 180   1          flag = 0;
 181   1        
 182   1        if((left1 == 1)&&(left2 == 0)&&(right1 == 1)&&(right2 == 0))   //1 0 1 0
 183   1          flag = 3;
 184   1        
 185   1        if((left1 == 1)&&(left2 == 0)&&(right1 == 1)&&(right2 == 1))   //1 0 1 1
 186   1          flag = 3;
 187   1        
 188   1        if((left1 == 1)&&(left2 == 1)&&(right1 == 0)&&(right2 == 0))   //1 1 0 0
 189   1          flag = 3;
 190   1         
 191   1        if((left1 == 1)&&(left2 == 1)&&(right1 == 0)&&(right2 == 1))   //1 1 0 1
 192   1          flag = 3;
 193   1      
 194   1        if((left1 == 1)&&(left2 == 1)&&(right1 == 1)&&(right2 == 0))   //1 1 1 0
 195   1          flag = 3;
 196   1        
 197   1        if((left1 == 1)&&(left2 == 1)&&(right1 == 1)&&(right2 == 1))   //1 1 1 1
 198   1          flag = 5;
 199   1        
 200   1        switch(flag)
 201   1        {
 202   2          case 0:Forward();break;
 203   2          
 204   2          case 1:TurnLeft1();break; 
 205   2          
 206   2          case 2:TurnLeft2();break;
 207   2        
 208   2          case 3:TurnRight1();break;
 209   2          
 210   2          case 4:TurnRight2();break;
 211   2          
 212   2          case 5:Backward() ;break;
 213   2          
 214   2          default:Stop();break;
 215   2        }
 216   1      }
 217          
 218          void InterruptTime0() interrupt 1
 219          {
 220   1        PWMCnt1++;
 221   1        PWMCnt2++;
 222   1        
 223   1        if(PWMCnt1  >= 200)
 224   1        {
 225   2          PWMCnt1 = 0;
 226   2        }
 227   1        if(PWMCnt1 <= cntPWM1)
 228   1        {
 229   2          ENA = 1;
 230   2        }
 231   1        else
 232   1        {
 233   2          ENA = 0;
 234   2        }
 235   1      
 236   1        if(PWMCnt2 >= 200)
 237   1        {
 238   2          PWMCnt2 = 0;
 239   2        }
 240   1        if(PWMCnt2 <= cntPWM2)
C51 COMPILER V9.01   DRIVE                                                                 11/07/2021 19:37:40 PAGE 5   

 241   1        {
 242   2          ENB = 1;
 243   2        }
 244   1        else
 245   1        {
 246   2          ENB = 0;
 247   2        }
 248   1      
 249   1        TH0 = (65536 - 50)/256;
 250   1        TL0 = (65536 - 50)%256;
 251   1      }
 252          
 253          //void InterruptTime1() interrupt 3
 254          //{
 255          //  unsigned int i;
 256          //  i++;
 257          //  if(i==1000)
 258          //    if(i==5)
 259          //    {
 260          //      i=0;
 261          //      j++;
 262          //    }
 263          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    483    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
